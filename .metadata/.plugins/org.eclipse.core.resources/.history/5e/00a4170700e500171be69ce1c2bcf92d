#include <ros/ros.h>
#include <ros/console.h>
#include <iostream>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include "../include/hardware_communication/SerialPort.h"
#include "../include/hardware_communication/RobotGoal.h"
#include "../include/hardware_communication/RobotState.h"

using namespace std;
using namespace ros;

int set_interface_attribs(int fd, int speed) {
	struct termios tty;

	if (tcgetattr(fd, &tty) < 0) {
		printf("Error from tcgetattr: %s\n", strerror(errno));
		return -1;
	}

	cfsetospeed(&tty, (speed_t) speed);
	cfsetispeed(&tty, (speed_t) speed);

	tty.c_cflag |= (CLOCAL | CREAD); /* ignore modem controls */
	tty.c_cflag &= ~CSIZE;
	tty.c_cflag |= CS8; /* 8-bit characters */
	tty.c_cflag &= ~PARENB; /* no parity bit */
	tty.c_cflag &= ~CSTOPB; /* only need 1 stop bit */
	tty.c_cflag &= ~CRTSCTS; /* no hardware flowcontrol */

	/* setup for non-canonical mode */
	tty.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL
			| IXON);
	tty.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
	tty.c_oflag &= ~OPOST;

	/* fetch bytes as they become available */
	tty.c_cc[VMIN] = 1;
	tty.c_cc[VTIME] = 1;

	if (tcsetattr(fd, TCSANOW, &tty) != 0) {
		printf("Error from tcsetattr: %s\n", strerror(errno));
		return -1;
	}
	return 0;
}

void set_mincount(int fd, int mcount) {
	struct termios tty;

	if (tcgetattr(fd, &tty) < 0) {
		printf("Error tcgetattr: %s\n", strerror(errno));
		return;
	}

	tty.c_cc[VMIN] = mcount ? 1 : 0;
	tty.c_cc[VTIME] = 5; /* half second timer */

	if (tcsetattr(fd, TCSANOW, &tty) < 0)
		printf("Error tcsetattr: %s\n", strerror(errno));
}

int main(int argc, char **argv) {
	ros::init(argc, argv, "field_ROI");
	ros::NodeHandle n;
	ROS_INFO("Initialized Serial Port");
	// Opens the port and fd
	char *portname = "/dev/ttyS0";
	int fd = open(portname, O_RDWR | O_NOCTTY | O_SYNC);
	int wlen;
	if (fd < 0) {
		printf("Error opening %s: %s\n", portname, strerror(errno));
		return -1;
	}
	set_interface_attribs(fd, B9600);
	ROS_INFO("Initialized Serial Port");

	// Output poll
	RobotGoal goal;
	goal.a = 1;
	sprintf(goal.message, "Message here\n");

	ros::Rate r(10);
	while (ros::ok()) {
		wlen = write(fd, &goal, sizeof(RobotGoal));
		if (wlen != 7) {
			printf("Error from write: %d, %d\n", wlen, errno);
		}
		tcdrain(fd);
		goal.a++;
		ROS_INFO("Sent Message %d", goal.a);

		// Acknowledgment
		char buf[80];
		char key[] = "ACK";
		while(strcmp(buf, key)) {
			int rdlen = read(fd, buf, sizeof(buf) - 1);
			if (rdlen > 0) {
				buf[rdlen] = 0;
				cout << buf << endl;
				wlen = write(fd, buf, sizeof(buf)); // Refreshes the buffer
			} else if (rdlen < 0) {
				printf("Error from read: %d: %s\n", rdlen, strerror(errno));
			}
		}

		ROS_INFO("Ack Message %d", goal.a);

		r.sleep();
	}
}
