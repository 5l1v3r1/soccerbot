#include <ros/ros.h>
#include <ros/console.h>
#include <iostream>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/select.h>
#include "../include/hardware_communication/SerialPort.h"
#include "../include/hardware_communication/RobotGoal.h"
#include "../include/hardware_communication/RobotState.h"

using namespace std;
using namespace ros;

int set_interface_attribs(int fd, int speed) {
	struct termios tty;

	if (tcgetattr(fd, &tty) < 0) {
		printf("Error from tcgetattr: %s\n", strerror(errno));
		return -1;
	}

	cfsetospeed(&tty, (speed_t) speed);
	cfsetispeed(&tty, (speed_t) speed);

	tty.c_cflag |= (CLOCAL | CREAD); /* ignore modem controls */
	tty.c_cflag &= ~CSIZE;
	tty.c_cflag |= CS8; /* 8-bit characters */
	tty.c_cflag &= ~PARENB; /* no parity bit */
	tty.c_cflag &= ~CSTOPB; /* only need 1 stop bit */
	tty.c_cflag &= ~CRTSCTS; /* no hardware flowcontrol */

	/* setup for non-canonical mode */
	tty.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL
			| IXON);
	tty.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
	tty.c_oflag &= ~OPOST;

	/* fetch bytes as they become available */
	tty.c_cc[VMIN] = 1;
	tty.c_cc[VTIME] = 1;

	if (tcsetattr(fd, TCSANOW, &tty) != 0) {
		printf("Error from tcsetattr: %s\n", strerror(errno));
		return -1;
	}
	return 0;
}

void set_mincount(int fd, int mcount) {
	struct termios tty;

	if (tcgetattr(fd, &tty) < 0) {
		printf("Error tcgetattr: %s\n", strerror(errno));
		return;
	}

	tty.c_cc[VMIN] = mcount ? 1 : 0;
	tty.c_cc[VTIME] = 5; /* half second timer */

	if (tcsetattr(fd, TCSANOW, &tty) < 0)
		printf("Error tcsetattr: %s\n", strerror(errno));
}

int main(int argc, char **argv) {
	ros::init(argc, argv, "hardware_communication");
	ros::NodeHandle n;
	// Opens the port and fd
	char *portname = "/dev/ttyACM0";
	int fd = open(portname, O_RDWR | O_NOCTTY | O_SYNC | O_NONBLOCK);
	int wlen;
	if (fd < 0) {
		printf("Error opening %s: %s\n", portname, strerror(errno));
		return -1;
	}
	set_interface_attribs(fd, B9600);
	ROS_INFO("Initialized Serial Port");

	fd_set serialfd;

	timeval t;
	t.tv_usec = 0;
	t.tv_sec = 0;

	// Output poll
	RobotGoal goal;
	goal.a = 1;
	sprintf(goal.message, "Message here\n");

	ros::Rate r(1);
	while (ros::ok()) {
		// Acknowledgment
		char buf[80] = {0};
		while(strcmp(buf, "A") != 0) {

			// Send message
			ROS_ERROR("Sending message %d", goal.a);
			wlen = write(fd, &goal, sizeof(RobotGoal));
			if (wlen != 7) {
				printf("Error from write: %d, %d\n", wlen, errno);
			}
			tcdrain(fd);
			goal.a++;
			ROS_ERROR("Sent message %d", goal.a);

			// Wait for acknowledgment

			FD_ZERO(&serialfd);
			FD_SET(fd, &serialfd);
			t.tv_usec = 100000;
			t.tv_sec = 5;
//
//			int retval = select(2, &serialfd, NULL, NULL, &t);
//			if (retval == -1) {
//				exit(4);
//			}

			if (FD_ISSET(fd, &serialfd)) {
				int rdlen = read(fd, buf, sizeof(buf) - 1);
				ROS_ERROR("Sent message %d", goal.a);

				if (rdlen > 0) {
					buf[rdlen] = 0;
					ROS_ERROR(buf);
				} else if (rdlen < 0) {
					printf("Error from read: %d: %s\n", rdlen, strerror(errno));
				}
			}

			ROS_ERROR("Waiting %d", goal.a);
		}
		memset(buf, 0, sizeof(buf));

		ROS_INFO("Ack Message %d", goal.a);

		r.sleep();
	}

	// Stream listen
	char buf[80];
	while(1) {
		int rdlen = read(fd, buf, sizeof(buf) - 1);
		if (rdlen > 0) {
			buf[rdlen] = 0;
			ROS_ERROR(buf);
			wlen = write(fd, buf, sizeof(buf)); // Refreshes the buffer
		} else if (rdlen < 0) {
			printf("Error from read: %d: %s\n", rdlen, strerror(errno));
		}
	}

}
