#include <ros/ros.h>
#include <ros/console.h>
#include <iostream>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <termio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/select.h>
#include "../include/hardware_communication/RobotGoal.h"
#include "../include/hardware_communication/RobotState.h"

using namespace std;
using namespace ros;


int open_port(void)
{
	int fd; // file description for the serial port

	fd = open("/dev/ttyACM0", O_RDWR | O_NOCTTY | O_NDELAY);

	if(fd == -1) // if open is unsucessful
	{
		//perror("open_port: Unable to open /dev/ttyS0 - ");
		printf("open_port: Unable to open /dev/ttyACM0. \n");
	}
	else
	{
		fcntl(fd, F_SETFL, 0);
		printf("port is open.\n");
	}

	return(fd);
} //open_port

int configure_port(int fd)      // configure the port
{
	struct termios port_settings;      // structure to store the port settings in

	cfsetispeed(&port_settings, B115200);    // set baud rates
	cfsetospeed(&port_settings, B115200);

	port_settings.c_cflag &= ~PARENB;    // set no parity, stop bits, data bits
	port_settings.c_cflag &= ~CSTOPB;
	port_settings.c_cflag &= ~CSIZE;
	port_settings.c_cflag |= CS8;

	tcsetattr(fd, TCSANOW, &port_settings);    // apply the settings to the port
	return(fd);

} //configure_port

int query_modem(int fd)   // query modem with an AT command
{
	char n;
	fd_set rdfs;
	struct timeval timeout;

	// initialise the timeout structure
	timeout.tv_sec = 10; // ten second timeout
	timeout.tv_usec = 0;

	//Create byte array
	unsigned char send_bytes[] = { 0x02, 0xFA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, 0x01, 0x21, 0x03};


	write(fd, send_bytes, 13);  //Send data
	printf("Wrote the bytes. \n");

	// do the select
	n = select(fd + 1, &rdfs, NULL, NULL, &timeout);

	// check if an error has occured
	if(n < 0)
	{
	 ROS_ERROR("select failed\n");
	}
	else if (n == 0)
	{
		ROS_ERROR("Timeout!");
	}
	else
	{
		ROS_ERROR("\nBytes detected on the port!\n");
	}

	return 0;

} //query_modem

int main(int argc, char **argv) {
	ros::init(argc, argv, "hardware_communication");
	ros::NodeHandle n;
	// Opens the port and fd

	int fd = open_port();
	configure_port(fd);
	query_modem(fd);
	while(1);

	ROS_INFO("Initialized Serial Port");

	fd_set serialfd;

	timeval t;
	t.tv_usec = 0;
	t.tv_sec = 1;

	// Output poll
	RobotGoal goal;
	goal.a = 1;
	sprintf(goal.message, "Message here\n");

	ros::Rate r(1);
	while (ros::ok()) {
		// Acknowledgment
		char buf[80] = {0};
		while(strcmp(buf, "ACK") != 0) {

			// Send message
			ROS_ERROR("Sending message %d", goal.a);
			int wlen = write(fd, &goal, sizeof(RobotGoal));
			if (wlen != 7) {
				printf("Error from write: %d, %d\n", wlen, errno);
			}
			tcdrain(fd);
			goal.a++;
			ROS_ERROR("Sent message %d", goal.a);

			// Wait for acknowledgment

			FD_ZERO(&serialfd);
			FD_SET(fd, &serialfd);

			t.tv_sec = 1;

			int retval = select(fd+1, &serialfd, NULL, NULL, &t);
			if (retval == -1) {
				exit(4);
			}
			else if (retval == 0) {
				ROS_ERROR("Timeout");
			}
			else {

				int rdlen = read(fd, buf, sizeof(buf) - 1);
				if (rdlen > 0) {
					buf[rdlen] = 0;
					ROS_ERROR(buf);
					break;
				} else if (rdlen < 0) {
					printf("Error from read: %d: %s\n", rdlen, strerror(errno));
				}

			}

			ROS_ERROR("Waiting %d", goal.a);
		}
		memset(buf, 0, sizeof(buf));

		ROS_INFO("Ack Message %d", goal.a);

		r.sleep();
	}
}
