#include <ros/ros.h>
#include <ros/console.h>
#include <iostream>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <termio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/select.h>
#include "../include/hardware_communication/RobotGoal.h"
#include "../include/hardware_communication/RobotState.h"

using namespace std;
using namespace ros;


int open_port(void)
{
	int fd; // file description for the serial port

	fd = open("/dev/ttyACM0", O_RDWR | O_NOCTTY | O_NDELAY);

	if(fd == -1) // if open is unsucessful
	{
		//perror("open_port: Unable to open /dev/ttyS0 - ");
		printf("open_port: Unable to open /dev/ttyACM0. \n");
	}
	else
	{
		fcntl(fd, F_SETFL, 0);
		printf("port is open.\n");
	}

	return(fd);
} //open_port

int configure_port(int fd)      // configure the port
{
	struct termios port_settings;      // structure to store the port settings in

	cfsetispeed(&port_settings, B115200);    // set baud rates
	cfsetospeed(&port_settings, B115200);

	port_settings.c_cflag &= ~PARENB;    // set no parity, stop bits, data bits
	port_settings.c_cflag &= ~CSTOPB;
	port_settings.c_cflag &= ~CSIZE;
	port_settings.c_cflag |= CS8;

	tcsetattr(fd, TCSANOW, &port_settings);    // apply the settings to the port
	return(fd);

} //configure_port

void set_mincount(int fd, int mcount) {
	struct termios tty;

	if (tcgetattr(fd, &tty) < 0) {
		printf("Error tcgetattr: %s\n", strerror(errno));
		return;
	}

	tty.c_cc[VMIN] = mcount ? 1 : 0;
	tty.c_cc[VTIME] = 5; /* half second timer */

	if (tcsetattr(fd, TCSANOW, &tty) < 0)
		printf("Error tcsetattr: %s\n", strerror(errno));
}

int main(int argc, char **argv) {
	ros::init(argc, argv, "hardware_communication");
	ros::NodeHandle n;
	// Opens the port and fd

	open_port()''
	ROS_INFO("Initialized Serial Port");

	fd_set serialfd;

	timeval t;
	t.tv_usec = 0;
	t.tv_sec = 1;

	// Output poll
	RobotGoal goal;
	goal.a = 1;
	sprintf(goal.message, "Message here\n");

	ros::Rate r(1);
	while (ros::ok()) {
		// Acknowledgment
		char buf[80] = {0};
		while(strcmp(buf, "ACK") != 0) {

			// Send message
			ROS_ERROR("Sending message %d", goal.a);
			wlen = write(fd, &goal, sizeof(RobotGoal));
			if (wlen != 7) {
				printf("Error from write: %d, %d\n", wlen, errno);
			}
			tcdrain(fd);
			goal.a++;
			ROS_ERROR("Sent message %d", goal.a);

			// Wait for acknowledgment

			FD_ZERO(&serialfd);
			FD_SET(fd, &serialfd);

			t.tv_sec = 1;

			int retval = select(fd+1, &serialfd, NULL, NULL, &t);
			if (retval == -1) {
				exit(4);
			}
			else if (retval == 0) {
				ROS_ERROR("Timeout");
			}
			else {

				int rdlen = read(fd, buf, sizeof(buf) - 1);
				if (rdlen > 0) {
					buf[rdlen] = 0;
					ROS_ERROR(buf);
					break;
				} else if (rdlen < 0) {
					printf("Error from read: %d: %s\n", rdlen, strerror(errno));
				}

			}

			ROS_ERROR("Waiting %d", goal.a);
		}
		memset(buf, 0, sizeof(buf));

		ROS_INFO("Ack Message %d", goal.a);

		r.sleep();
	}
}
